/**
  ******************************************************************************
  * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/httpser-netconn.c 
  * @author  MCD Application Team
  * @brief   Basic http server implementation using LwIP netconn API  
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* Includes ------------------------------------------------------------------*/
#include "lwip/apps/fs.h"
#include "string.h"
#include "httpserver-netconn.h"
#include "cmsis_os.h"
#include "stm32_secure_patching_bootloader_interface_v1.3.0.h"

#include <stdio.h>

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
#define WEBSERVER_THREAD_PRIO    ( osPriorityAboveNormal )

/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
u32_t nPageHits = 0;

/* Format of dynamic web page: the page header */
static const unsigned char PAGE_START[] = {
0x3c,0x21,0x44,0x4f,0x43,0x54,0x59,0x50,0x45,0x20,0x68,0x74,0x6d,0x6c,0x20,0x50,
0x55,0x42,0x4c,0x49,0x43,0x20,0x22,0x2d,0x2f,0x2f,0x57,0x33,0x43,0x2f,0x2f,0x44,
0x54,0x44,0x20,0x48,0x54,0x4d,0x4c,0x20,0x34,0x2e,0x30,0x31,0x2f,0x2f,0x45,0x4e,
0x22,0x20,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x77,0x33,
0x2e,0x6f,0x72,0x67,0x2f,0x54,0x52,0x2f,0x68,0x74,0x6d,0x6c,0x34,0x2f,0x73,0x74,
0x72,0x69,0x63,0x74,0x2e,0x64,0x74,0x64,0x22,0x3e,0x0d,0x0a,0x3c,0x68,0x74,0x6d,
0x6c,0x3e,0x0d,0x0a,0x3c,0x68,0x65,0x61,0x64,0x3e,0x0d,0x0a,0x20,0x20,0x3c,0x74,
0x69,0x74,0x6c,0x65,0x3e,0x53,0x54,0x4d,0x33,0x32,0x46,0x34,0x78,0x78,0x54,0x41,
0x53,0x4b,0x53,0x3c,0x2f,0x74,0x69,0x74,0x6c,0x65,0x3e,0x0d,0x0a,0x20,0x20,0x3c,
0x6d,0x65,0x74,0x61,0x20,0x68,0x74,0x74,0x70,0x2d,0x65,0x71,0x75,0x69,0x76,0x3d,
0x22,0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x54,0x79,0x70,0x65,0x22,0x0d,0x0a,
0x20,0x63,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x3d,0x22,0x74,0x65,0x78,0x74,0x2f,0x68,
0x74,0x6d,0x6c,0x3b,0x20,0x63,0x68,0x61,0x72,0x73,0x65,0x74,0x3d,0x77,0x69,0x6e,
0x64,0x6f,0x77,0x73,0x2d,0x31,0x32,0x35,0x32,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x3c,
0x6d,0x65,0x74,0x61,0x20,0x68,0x74,0x74,0x70,0x2d,0x65,0x71,0x75,0x69,0x76,0x3d,
0x22,0x72,0x65,0x66,0x72,0x65,0x73,0x68,0x22,0x20,0x63,0x6f,0x6e,0x74,0x65,0x6e,
0x74,0x3d,0x22,0x31,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x3c,0x6d,0x65,0x74,0x61,0x20,
0x63,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x3d,0x22,0x4d,0x53,0x48,0x54,0x4d,0x4c,0x20,
0x36,0x2e,0x30,0x30,0x2e,0x32,0x38,0x30,0x30,0x2e,0x31,0x35,0x36,0x31,0x22,0x20,
0x6e,0x61,0x6d,0x65,0x3d,0x22,0x47,0x45,0x4e,0x45,0x52,0x41,0x54,0x4f,0x52,0x22,
0x3e,0x0d,0x0a,0x20,0x20,0x3c,0x73,0x74,0x79,0x6c,0x65,0x20,0x3d,0x22,0x66,0x6f,
0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x6e,0x6f,0x72,0x6d,0x61,
0x6c,0x3b,0x20,0x66,0x6f,0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,0x6c,0x79,0x3a,0x20,
0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,0x22,0x3e,0x3c,0x2f,0x73,0x74,0x79,0x6c,
0x65,0x3e,0x0d,0x0a,0x3c,0x2f,0x68,0x65,0x61,0x64,0x3e,0x0d,0x0a,0x3c,0x62,0x6f,
0x64,0x79,0x3e,0x0d,0x0a,0x3c,0x68,0x34,0x3e,0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x20,
0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,
0x6c,0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,0x22,0x3e,0x3c,0x73,
0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x62,0x69,0x67,0x3e,0x3c,0x62,0x69,0x67,0x3e,0x3c,
0x62,0x69,0x67,0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,
0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,
0x3e,0x3c,0x62,0x69,0x67,0x3e,0x3c,0x73,0x74,0x72,0x6f,0x6e,0x67,0x3e,0x3c,0x65,
0x6d,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,
0x22,0x66,0x6f,0x6e,0x74,0x2d,0x73,0x74,0x79,0x6c,0x65,0x3a,0x20,0x69,0x74,0x61,
0x6c,0x69,0x63,0x3b,0x22,0x3e,0x53,0x54,0x4d,0x33,0x32,0x46,0x34,0x78,0x78,0x20,
0x4c,0x69,0x73,0x74,0x20,0x6f,0x66,0x20,0x74,0x61,0x73,0x6b,0x73,0x20,0x61,0x6e,
0x64,0x0d,0x0a,0x74,0x68,0x65,0x69,0x72,0x20,0x73,0x74,0x61,0x74,0x75,0x73,0x3c,
0x2f,0x73,0x70,0x61,0x6e,0x3e,0x3c,0x2f,0x65,0x6d,0x3e,0x3c,0x2f,0x73,0x74,0x72,
0x6f,0x6e,0x67,0x3e,0x3c,0x2f,0x62,0x69,0x67,0x3e,0x3c,0x2f,0x62,0x69,0x67,0x3e,
0x3c,0x2f,0x62,0x69,0x67,0x3e,0x3c,0x2f,0x62,0x69,0x67,0x3e,0x3c,0x2f,0x73,0x6d,
0x61,0x6c,0x6c,0x3e,0x3c,0x2f,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x2f,0x68,0x34,
0x3e,0x0d,0x0a,0x3c,0x68,0x72,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x77,0x69,
0x64,0x74,0x68,0x3a,0x20,0x31,0x30,0x30,0x25,0x3b,0x20,0x68,0x65,0x69,0x67,0x68,
0x74,0x3a,0x20,0x32,0x70,0x78,0x3b,0x22,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x0d,0x0a,
0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,
0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,0x3e,0x0d,0x0a,0x3c,0x2f,
0x73,0x70,0x61,0x6e,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,
0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,
0x6f,0x6c,0x64,0x3b,0x22,0x3e,0x0d,0x0a,0x3c,0x74,0x61,0x62,0x6c,0x65,0x20,0x73,
0x74,0x79,0x6c,0x65,0x3d,0x22,0x77,0x69,0x64,0x74,0x68,0x3a,0x20,0x39,0x36,0x31,
0x70,0x78,0x3b,0x20,0x68,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x33,0x30,0x70,0x78,
0x3b,0x22,0x20,0x62,0x6f,0x72,0x64,0x65,0x72,0x3d,0x22,0x31,0x22,0x0d,0x0a,0x20,
0x63,0x65,0x6c,0x6c,0x70,0x61,0x64,0x64,0x69,0x6e,0x67,0x3d,0x22,0x32,0x22,0x20,
0x63,0x65,0x6c,0x6c,0x73,0x70,0x61,0x63,0x69,0x6e,0x67,0x3d,0x22,0x32,0x22,0x3e,
0x0d,0x0a,0x20,0x20,0x3c,0x74,0x62,0x6f,0x64,0x79,0x3e,0x0d,0x0a,0x20,0x20,0x20,
0x20,0x3c,0x74,0x72,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x74,0x64,
0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x66,
0x61,0x6d,0x69,0x6c,0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,0x20,
0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,
0x64,0x3b,0x20,0x66,0x6f,0x6e,0x74,0x2d,0x73,0x74,0x79,0x6c,0x65,0x3a,0x20,0x69,
0x74,0x61,0x6c,0x69,0x63,0x3b,0x20,0x62,0x61,0x63,0x6b,0x67,0x72,0x6f,0x75,0x6e,
0x64,0x2d,0x63,0x6f,0x6c,0x6f,0x72,0x3a,0x20,0x72,0x67,0x62,0x28,0x35,0x31,0x2c,
0x20,0x35,0x31,0x2c,0x20,0x32,0x35,0x35,0x29,0x3b,0x20,0x74,0x65,0x78,0x74,0x2d,
0x61,0x6c,0x69,0x67,0x6e,0x3a,0x20,0x63,0x65,0x6e,0x74,0x65,0x72,0x3b,0x22,0x3e,
0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x61,0x0d,0x0a,0x20,0x68,0x72,0x65,0x66,
0x3d,0x22,0x2f,0x53,0x54,0x4d,0x33,0x32,0x46,0x34,0x78,0x78,0x2e,0x68,0x74,0x6d,
0x6c,0x22,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,
0x63,0x6f,0x6c,0x6f,0x72,0x3a,0x20,0x77,0x68,0x69,0x74,0x65,0x3b,0x22,0x3e,0x48,
0x6f,0x6d,0x65,0x0d,0x0a,0x70,0x61,0x67,0x65,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,
0x3c,0x2f,0x61,0x3e,0x3c,0x2f,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x2f,0x74,0x64,
0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x74,0x64,0x0d,0x0a,0x20,0x73,
0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,0x6c,
0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,0x20,0x66,0x6f,0x6e,0x74,
0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x20,0x66,
0x6f,0x6e,0x74,0x2d,0x73,0x74,0x79,0x6c,0x65,0x3a,0x20,0x69,0x74,0x61,0x6c,0x69,
0x63,0x3b,0x20,0x62,0x61,0x63,0x6b,0x67,0x72,0x6f,0x75,0x6e,0x64,0x2d,0x63,0x6f,
0x6c,0x6f,0x72,0x3a,0x20,0x72,0x67,0x62,0x28,0x35,0x31,0x2c,0x20,0x35,0x31,0x2c,
0x20,0x32,0x35,0x35,0x29,0x3b,0x20,0x74,0x65,0x78,0x74,0x2d,0x61,0x6c,0x69,0x67,
0x6e,0x3a,0x20,0x63,0x65,0x6e,0x74,0x65,0x72,0x3b,0x22,0x3e,0x3c,0x61,0x0d,0x0a,
0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x53,0x54,0x4d,0x33,0x32,0x46,0x34,0x78,0x78,
0x41,0x44,0x43,0x2e,0x68,0x74,0x6d,0x6c,0x22,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x20,
0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,
0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,0x3e,0x3c,0x2f,0x73,0x70,0x61,
0x6e,0x3e,0x3c,0x2f,0x61,0x3e,0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x61,0x0d,
0x0a,0x20,0x68,0x72,0x65,0x66,0x3d,0x22,0x2f,0x53,0x54,0x4d,0x33,0x32,0x46,0x34,
0x78,0x78,0x54,0x41,0x53,0x4b,0x53,0x2e,0x68,0x74,0x6d,0x6c,0x22,0x3e,0x3c,0x73,
0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x63,0x6f,0x6c,0x6f,0x72,
0x3a,0x20,0x77,0x68,0x69,0x74,0x65,0x3b,0x22,0x3e,0x4c,0x69,0x73,0x74,0x0d,0x0a,
0x6f,0x66,0x20,0x74,0x61,0x73,0x6b,0x73,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,0x3c,
0x2f,0x61,0x3e,0x3c,0x2f,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,0x2f,0x74,0x64,0x3e,
0x0d,0x0a,0x20,0x20,0x20,0x20,0x3c,0x2f,0x74,0x72,0x3e,0x0d,0x0a,0x20,0x20,0x3c,
0x2f,0x74,0x62,0x6f,0x64,0x79,0x3e,0x0d,0x0a,0x3c,0x2f,0x74,0x61,0x62,0x6c,0x65,
0x3e,0x0d,0x0a,0x3c,0x62,0x72,0x3e,0x0d,0x0a,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,
0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,
0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,
0x3e,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x3c,
0x73,0x70,0x61,0x6e,0x0d,0x0a,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,
0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,0x6c,0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,
0x6e,0x61,0x3b,0x22,0x3e,0x4e,0x75,0x6d,0x62,0x65,0x72,0x20,0x6f,0x66,0x20,0x70,
0x61,0x67,0x65,0x20,0x68,0x69,0x74,0x73,0x3a,0x0d,0x0a,0x00};



/* Format of dynamic web page: the page header */
/* ---------- - Src / fwupd - page - start.html------------------ */
static const unsigned char PAGE_START_FWUPD[] = {
0x3c,0x21,0x44,0x4f,0x43,0x54,0x59,0x50,0x45,0x20,0x68,0x74,0x6d,0x6c,0x20,0x50,
0x55,0x42,0x4c,0x49,0x43,0x20,0x22,0x2d,0x2f,0x2f,0x57,0x33,0x43,0x2f,0x2f,0x44,
0x54,0x44,0x20,0x48,0x54,0x4d,0x4c,0x20,0x34,0x2e,0x30,0x31,0x2f,0x2f,0x45,0x4e,
0x22,0x20,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x77,0x33,
0x2e,0x6f,0x72,0x67,0x2f,0x54,0x52,0x2f,0x68,0x74,0x6d,0x6c,0x34,0x2f,0x73,0x74,
0x72,0x69,0x63,0x74,0x2e,0x64,0x74,0x64,0x22,0x3e,0x0d,0x0a,0x3c,0x68,0x74,0x6d,
0x6c,0x3e,0x0d,0x0a,0x3c,0x68,0x65,0x61,0x64,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,
0x3c,0x74,0x69,0x74,0x6c,0x65,0x3e,0x53,0x54,0x4d,0x33,0x32,0x46,0x34,0x78,0x78,
0x54,0x41,0x53,0x4b,0x53,0x3c,0x2f,0x74,0x69,0x74,0x6c,0x65,0x3e,0x0d,0x0a,0x20,
0x20,0x20,0x20,0x3c,0x6d,0x65,0x74,0x61,0x20,0x68,0x74,0x74,0x70,0x2d,0x65,0x71,
0x75,0x69,0x76,0x3d,0x22,0x43,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x2d,0x54,0x79,0x70,
0x65,0x22,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x63,0x6f,
0x6e,0x74,0x65,0x6e,0x74,0x3d,0x22,0x74,0x65,0x78,0x74,0x2f,0x68,0x74,0x6d,0x6c,
0x3b,0x20,0x63,0x68,0x61,0x72,0x73,0x65,0x74,0x3d,0x77,0x69,0x6e,0x64,0x6f,0x77,
0x73,0x2d,0x31,0x32,0x35,0x32,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x3c,0x6d,
0x65,0x74,0x61,0x20,0x63,0x6f,0x6e,0x74,0x65,0x6e,0x74,0x3d,0x22,0x4d,0x53,0x48,
0x54,0x4d,0x4c,0x20,0x36,0x2e,0x30,0x30,0x2e,0x32,0x38,0x30,0x30,0x2e,0x31,0x35,
0x36,0x31,0x22,0x20,0x6e,0x61,0x6d,0x65,0x3d,0x22,0x47,0x45,0x4e,0x45,0x52,0x41,
0x54,0x4f,0x52,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x3c,0x73,0x74,0x79,0x6c,
0x65,0x20,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,
0x20,0x6e,0x6f,0x72,0x6d,0x61,0x6c,0x3b,0x20,0x66,0x6f,0x6e,0x74,0x2d,0x66,0x61,
0x6d,0x69,0x6c,0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,0x22,0x3e,
0x3c,0x2f,0x73,0x74,0x79,0x6c,0x65,0x3e,0x0d,0x0a,0x3c,0x2f,0x68,0x65,0x61,0x64,
0x3e,0x0d,0x0a,0x3c,0x62,0x6f,0x64,0x79,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x3c,
0x68,0x34,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x73,0x6d,
0x61,0x6c,0x6c,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,
0x66,0x61,0x6d,0x69,0x6c,0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,
0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x62,0x69,0x67,0x3e,0x0d,0x0a,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x3c,0x62,0x69,0x67,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x3c,0x62,0x69,0x67,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,
0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,
0x3b,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x3c,0x62,0x69,0x67,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x73,0x74,0x72,0x6f,0x6e,0x67,0x3e,
0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x65,0x6d,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,
0x22,0x66,0x6f,0x6e,0x74,0x2d,0x73,0x74,0x79,0x6c,0x65,0x3a,0x20,0x69,0x74,0x61,
0x6c,0x69,0x63,0x3b,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x53,0x54,0x4d,0x33,0x32,0x46,0x34,0x78,0x78,0x20,0x46,0x69,
0x72,0x6d,0x77,0x61,0x72,0x65,0x20,0x55,0x70,0x64,0x61,0x74,0x65,0x0d,0x0a,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,0x0d,0x0a,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x3c,0x2f,0x65,0x6d,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x2f,0x73,0x74,0x72,
0x6f,0x6e,0x67,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x3c,0x2f,0x62,0x69,0x67,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x3c,0x2f,0x62,0x69,0x67,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x2f,
0x62,0x69,0x67,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x2f,0x62,0x69,0x67,0x3e,0x0d,0x0a,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x2f,0x73,0x6d,0x61,0x6c,
0x6c,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x2f,0x73,0x6d,
0x61,0x6c,0x6c,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x3c,0x2f,0x68,0x34,0x3e,0x0d,
0x0a,0x20,0x20,0x20,0x20,0x3c,0x68,0x72,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,
0x77,0x69,0x64,0x74,0x68,0x3a,0x20,0x31,0x30,0x30,0x25,0x3b,0x20,0x68,0x65,0x69,
0x67,0x68,0x74,0x3a,0x20,0x32,0x70,0x78,0x3b,0x22,0x3e,0x3c,0x73,0x70,0x61,0x6e,
0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,
0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,0x3e,0x0d,0x0a,0x20,0x20,
0x20,0x20,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,
0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,
0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x3c,0x74,0x61,0x62,0x6c,0x65,0x20,0x73,0x74,0x79,0x6c,0x65,
0x3d,0x22,0x77,0x69,0x64,0x74,0x68,0x3a,0x20,0x39,0x36,0x31,0x70,0x78,0x3b,0x20,
0x68,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x33,0x30,0x70,0x78,0x3b,0x22,0x20,0x62,
0x6f,0x72,0x64,0x65,0x72,0x3d,0x22,0x31,0x22,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x63,0x65,0x6c,0x6c,0x70,0x61,
0x64,0x64,0x69,0x6e,0x67,0x3d,0x22,0x32,0x22,0x20,0x63,0x65,0x6c,0x6c,0x73,0x70,
0x61,0x63,0x69,0x6e,0x67,0x3d,0x22,0x32,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x74,0x62,0x6f,0x64,0x79,0x3e,0x0d,
0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x3c,0x74,0x72,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x74,0x64,0x20,0x73,
0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,0x6c,
0x79,0x3a,0x20,0x56,0x65,0x72,0x64,0x61,0x6e,0x61,0x3b,0x20,0x66,0x6f,0x6e,0x74,
0x2d,0x77,0x65,0x69,0x67,0x68,0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x20,0x66,
0x6f,0x6e,0x74,0x2d,0x73,0x74,0x79,0x6c,0x65,0x3a,0x20,0x69,0x74,0x61,0x6c,0x69,
0x63,0x3b,0x20,0x62,0x61,0x63,0x6b,0x67,0x72,0x6f,0x75,0x6e,0x64,0x2d,0x63,0x6f,
0x6c,0x6f,0x72,0x3a,0x20,0x72,0x67,0x62,0x28,0x35,0x31,0x2c,0x20,0x35,0x31,0x2c,
0x20,0x32,0x35,0x35,0x29,0x3b,0x20,0x74,0x65,0x78,0x74,0x2d,0x61,0x6c,0x69,0x67,
0x6e,0x3a,0x20,0x63,0x65,0x6e,0x74,0x65,0x72,0x3b,0x22,0x3e,0x0d,0x0a,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x0d,0x0a,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x61,0x20,0x68,0x72,
0x65,0x66,0x3d,0x22,0x2f,0x53,0x54,0x4d,0x33,0x32,0x46,0x34,0x78,0x78,0x2e,0x68,
0x74,0x6d,0x6c,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,0x74,0x79,
0x6c,0x65,0x3d,0x22,0x63,0x6f,0x6c,0x6f,0x72,0x3a,0x20,0x77,0x68,0x69,0x74,0x65,
0x3b,0x22,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x48,0x6f,0x6d,0x65,0x0d,0x0a,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x70,0x61,0x67,0x65,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,
0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x2f,
0x61,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x2f,0x73,0x6d,
0x61,0x6c,0x6c,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x2f,0x74,0x64,0x3e,0x0d,
0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x3c,0x2f,0x74,0x72,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x3c,0x2f,0x74,0x62,0x6f,0x64,0x79,0x3e,0x0d,0x0a,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x2f,0x74,0x61,0x62,0x6c,0x65,0x3e,0x0d,0x0a,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3c,0x62,0x72,0x3e,0x0d,0x0a,0x20,0x20,
0x20,0x20,0x3c,0x2f,0x73,0x70,0x61,0x6e,0x3e,0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,
0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,0x6f,0x6e,0x74,0x2d,0x77,0x65,0x69,0x67,0x68,
0x74,0x3a,0x20,0x62,0x6f,0x6c,0x64,0x3b,0x22,0x3e,0x3c,0x2f,0x73,0x70,0x61,0x6e,
0x3e,0x3c,0x73,0x6d,0x61,0x6c,0x6c,0x3e,0x0d,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x3c,0x73,0x70,0x61,0x6e,0x20,0x73,0x74,0x79,0x6c,0x65,0x3d,0x22,0x66,
0x6f,0x6e,0x74,0x2d,0x66,0x61,0x6d,0x69,0x6c,0x79,0x3a,0x20,0x56,0x65,0x72,0x64,
0x61,0x6e,0x61,0x3b,0x22,0x3e,0x42,0x6f,0x6f,0x74,0x6c,0x6f,0x61,0x64,0x65,0x72,
0x20,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x3a,0x0d,0x0a,0x0,
};
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

typedef enum {
    FWUPDATE_STATE_HEADER,
    FWUPDATE_STATE_OCTET_START,
    FWUPDATE_STATE_OCTET_STREAM,

} fwupdate_state_t;

typedef struct {

    fwupdate_state_t state;

    int content_length;
    int file_length;
    int accum_length;

    /* Data stream accumulation buffer to meet 8-byte size-alignment constraint with v1.3.0 .sfb file update */
    uint8_t accum_buf[8];
    uint8_t accum_buf_len;

} fwupdate_t;

static fwupdate_t fwupdate;

#define CONTENT_LENGTH_TAG      "Content-Length:"
#define OCTET_STREAM_TAG      "application/octet-stream\r\n\r\n"
#define EMPTY_LINE_TAG          "\r\n\r\n"

#define FWUPDATE_STATUS_ERROR          -1
#define FWUPDATE_STATUS_NONE            0
#define FWUPDATE_STATUS_INPROGRESS      1
#define FWUPDATE_STATUS_DONE            2

#if 1
static const char* SE_PATCH_StatusCodeStrings[] = {
    "None",
    "Completed",
    "Invalid arg - one or more invalid arguments supplied to API",
    "Invalid image - firmware image header checksum failed or not present",
    "Invalid source image",
    "Invalid target image",
    "Invalid patch tag",
    "Image too large - firmware image too large to fit into section",
    "Image too small - firmware image size invalid",
    "Section not available - specified section is not available",
    "Section erase failure - flash driver returned erase error",
    "Section write failure - flash driver returned write error",
    "Image version failure - firmware image version is not newer than current",
    "Invalid section key - section partitions may have changed",
    "Image verify tag failure - written image header checksum failed",
    "Image verify alg failure - written image checksum failed",
    "Image decrypt failure - cannot initialize decryption engine",
    "Invalid state - update engine in wrong state for action",
    "Invalid order - data received before firmware image header",
    "Too few bytes - not enough bytes received to process header",
    "Parser error - error in parsing .fmu firmware update image container format",
    "Decryption error - error running decryption engine",
    "Install error - error writing the final image valid tag bytes",
    "Flash error - could not initialize low level flash",
    "Flash segment error - could not setup the flash segment read layer",
    "Flash cipher error - could not setup the flash cipher write layer",
};

#endif

static const char* fwupdate_GetStatusCodeString(SE_PATCH_StatusCode code)
{
    static const char* emptyString = "";

#if 1
    if (code >= 0 && code < SE_PATCH_StatusCode__MAX__) {
        return SE_PATCH_StatusCodeStrings[code];
    }
    else {
        return emptyString;
    }
#else
    return emptyString;
#endif
}

/* Implement function SE_PATCH_PrintStatus which is actually not implemented. */
static void fwupdate_PrintStatus(SE_PATCH_Status* status)
{
#if 1 /* User needs to provide a prinf function */
     // completed, error, code, stage, accum bytes.
    printf("operation %s %s error, code is %s, stage %s, accumulated bytes %ld\n",
        (status->completed ? "completed" : "not completed"),
        (status->error ? "with" : "without"),
        (fwupdate_GetStatusCodeString(status->code)),
        (status->stage == SE_PATCH_Stage_UPDATE ? "UPDATE" : (status->stage == SE_PATCH_Stage_VERIFIED ? "VERIFIED" : "IDLE")),
        (status->accumBytes));
#endif
}

static const char* fwupdate_state_str(fwupdate_state_t state)
{
    switch (state) {
    case FWUPDATE_STATE_HEADER: return "HEADER";
    case FWUPDATE_STATE_OCTET_START: return "OCTET_START";
    case FWUPDATE_STATE_OCTET_STREAM: return "OCTET_STREAM";
    default:
        return "<unknown>";
    }

}

static const uint8_t fwupdate_error_html[] = {
    /* HTTP header */
    /* "HTTP/1.0 404 File not found
    " (29 bytes) */
    0x48, 0x54, 0x54, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x20, 0x34, 0x30, 0x34, 0x20, 0x46, 0x69, 0x6c,
    0x65, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x0d, 0x0a,
    /* "Server: lwIP/1.3.1 (http://savannah.nongnu.org/projects/lwip)
    " (63 bytes) */
    0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x3a, 0x20, 0x6c, 0x77, 0x49, 0x50, 0x2f, 0x31, 0x2e, 0x33,
    0x2e, 0x31, 0x20, 0x28, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x73, 0x61, 0x76, 0x61, 0x6e,
    0x6e, 0x61, 0x68, 0x2e, 0x6e, 0x6f, 0x6e, 0x67, 0x6e, 0x75, 0x2e, 0x6f, 0x72, 0x67, 0x2f, 0x70,
    0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x2f, 0x6c, 0x77, 0x69, 0x70, 0x29, 0x0d, 0x0a,
    /* "Content-type: text/html

    " (27 bytes) */
    0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x74, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x74, 0x65,
    0x78, 0x74, 0x2f, 0x68, 0x74, 0x6d, 0x6c, 0x0d, 0x0a, 0x0d, 0x0a,
    /* To this, write out the status code string */
};

static void fwupdate_send_err(struct netconn* conn, const char* err_str)
{
    netconn_write(conn, (const unsigned char*)fwupdate_error_html, (size_t)sizeof(fwupdate_error_html), NETCONN_NOCOPY);
    netconn_write(conn, (const unsigned char*)err_str, (size_t)strlen(err_str), NETCONN_NOCOPY);
}



static int fwupdate_multipart_state_machine(struct netconn* conn, char* buf, u16_t buflen)
{
    /* So how the multipart file upload appears to work (from Chrome):
    *  1. Get the POST header in one netconn_recv() buffer.
    *  2. From header get the content-length which will be the number of
    *     bytes in following netconn_recv() buffer(s).
    *  3. Compute number of file bytes by subtracting content of second netconn_recv()  buffer
    *     up to the "Content-Type: application/octet-stream\r\n\r\n"
    *  4. Continue to process netconn_recv()  buffers until file bytes are received.
    *  5. Send "200 OK" response and close connection.
    */
     

    /* Process the buffer as long as we can in one of these two scenarios only:
    In case of Chrome, multipart octet-stream comes in separate packet/buffer while
    in case of Postman, multipart octet-stream comes in same packet/buffer as POST header. 
    */

    int ret = FWUPDATE_STATUS_NONE;

    char* buf_start = buf;
    char* buf_end = buf + buflen; /* points to byte AFTER end of buffer! */

    /* Diagnostics */
    //print_buf((uint8_t*)buf, buflen);

    /* We advance the buffer pointer as parts are consumed.  Keep processing
    until buffer pointer gets nulled either as a result of not finding what we want
    or explicitly on error condition. 
    */
    while (buf && buf < buf_end) {

        printf("@ fwupdate buf_start=%p, buf=%p buf_end=%p state=%s\n", buf_start, buf, buf_end, fwupdate_state_str(fwupdate.state));

        switch (fwupdate.state)
        {
        case FWUPDATE_STATE_HEADER:
            /* Look for POST header */
            if ((buflen >= 12) && (strncmp(buf, "POST /upload", 12) == 0)) {
                ret = FWUPDATE_STATUS_ERROR; /* Error until we go to in progress */
                /* This buffer must have the complete POST header */
                printf("@ fwupdate -     Scanning HEADER\n");
                /* Diagnostics */
                print_buf((uint8_t*)buf, buflen);
                buf = strstr(buf, CONTENT_LENGTH_TAG);
                if (buf) {
                    buf += strlen(CONTENT_LENGTH_TAG);
                    fwupdate.content_length = atoi(buf);
                    /* sanity check  */
                    if (fwupdate.content_length > 0) {
                        /* Having obtained content length, need to next find the 
                        end of the header, denoted by an empty line. 
                        This is where the content-length starts from. */
                        buf = strstr(buf, EMPTY_LINE_TAG);
                        if (buf) {
                            buf += strlen(EMPTY_LINE_TAG);
                            /* To get the length of the file, have to subtract all bytes up to and including 
                            application/octet-stream\r\n\r\n" 
                            */
                            /* advance the buffer reference point to here */
                            buf_start = buf;
                            /* Got what we need/expect and must wait for the "octet-stream" content-type in
                             the next multipart header packet. */
                            fwupdate.state = FWUPDATE_STATE_OCTET_START;
                            ret = FWUPDATE_STATUS_INPROGRESS;

                            printf("@ fwupdate - Have content len=%d\n", fwupdate.content_length);
                        }
                    }
                    else {
                        buf = 0;
                    }
                }
            }
            else {
                buf = 0;
            }
            break;
        case FWUPDATE_STATE_OCTET_START:

            ret = FWUPDATE_STATUS_ERROR;
            fwupdate.state = FWUPDATE_STATE_HEADER;

            /* Look for the start of the firmware update file */
            buf = strstr(buf, OCTET_STREAM_TAG);
            if (buf) {
                buf += strlen(OCTET_STREAM_TAG);
                int multipart_length = buf - buf_start;
                fwupdate.file_length = fwupdate.content_length - multipart_length;
                printf("@ fwupdate content len=%d multipart len=%d file len=%d\n", 
                    fwupdate.content_length, multipart_length, fwupdate.file_length);
                /* Now can init the update */
                SE_PATCH_StartInfo info = {
                    .type = SE_PATCH_ImageType_APP, /* App type */
                    .rebootDelay = SE_PATCH_RebootDelay_IMMEDIATE, /* Patch engine automatically reboots when update is complete */
                    .totalLength = fwupdate.file_length, /* Could be a patch or full image; either way used as a sanity check but not necessary to use here. */
                };
                SE_PATCH_Status se_patch_status;
                SE_PATCH_InitStatus(&se_patch_status);
                SE_ErrorStatus se_status = SE_PATCH_Init(&se_patch_status, &info);
                printf("@ fwupdate INIT %d\n", se_status);
                fwupdate_PrintStatus(&se_patch_status);
                if (se_status == SE_SUCCESS) {
                    /* Now need to consume rest of buffer as the file */
                    fwupdate.state = FWUPDATE_STATE_OCTET_STREAM;
                    fwupdate.accum_length = 0;
                    fwupdate.accum_buf_len = 0;
                    ret = FWUPDATE_STATUS_INPROGRESS;
                }
                else {
                    fwupdate_send_err(conn, fwupdate_GetStatusCodeString(se_patch_status.code));
                }
            }

            break;

        case FWUPDATE_STATE_OCTET_STREAM:
        {
            /* All of "buf" until "buf_end"-1 is considered file data at this point */
            /* It is safe to feed this buffer right into the patching engine.
            It could block here while flash is being erased & written if we have enough and correct bytes */

            /* stm32-secure-patching-bootloader v1.3.0 errata:
                [2] SE_PATCH_Data API will fail if presented with a full-image update file (.sfb) data buffer length
                    that is not a multiple of the platform's flash write size: typically 8 bytes (doubleword).
                    Workaround is to ensure that the API is called with an 8-byte-multiple length buffer. 
                    Note: this is not necessary for .sfbp (patch) files, but having it in place won't affect .sfbp updates.

                    For ethernet we have no control over how many bytes may be sent so we implement a buffer
                    scheme to accumulate bytes until we meet the criteria for each SE_PATCH_Data() call.
             */

            /* total bytes we have in this current buffer - these all have to be processed with SE_PATCH_Data()
               or stored in the accum_buf */
            int len = buf_end - buf;
            printf("@ fwupdate len=%d\n", len);

            const uint8_t* input_buf; /* pointer to data we will consume */
            int input_buf_len = 0; /* number of bytes to consume from this input buffer pointer */
            int offset = 0; /* offset into the original buffer */

            ret = FWUPDATE_STATUS_INPROGRESS;

            SE_PATCH_Status se_patch_status;
            SE_PATCH_InitStatus(&se_patch_status);

            /* One way or another we MUST consume all bytes in the received packet (buf).
            * Bytes that aren't a multiple of the accumulation buffer size are stored
            * in the accumulation buffer until next packet.
            */
            while (len > 0) {

                /* ----------------------------------------------------------------- */
                input_buf = 0;

                if (fwupdate.accum_buf_len > 0 ||
                    len < sizeof(fwupdate.accum_buf)) {
                    /* We have existing bytes in the buffer or and /or too few bytes to process.
                      Store them in our internal buffer.
                     */
                    int avail = sizeof(fwupdate.accum_buf) - fwupdate.accum_buf_len;
                    int copy = len > avail ? avail : len;
                    memcpy(fwupdate.accum_buf + fwupdate.accum_buf_len, buf + offset, copy);
                    fwupdate.accum_buf_len += copy;

                    /* consumed these bytes into the front end buffer */
                    len -= copy;
                    offset += copy;
                    
                    printf("@   accum %d bytes\n", copy);
                }

                /* If the front end buffer is full, use it */
                if (fwupdate.accum_buf_len == sizeof(fwupdate.accum_buf)) {
                    printf("@   use accum_buf\n");
                    /* We now have all required minimum bytes in the front end buffer.Process them */
                    input_buf = fwupdate.accum_buf;
                    fwupdate.accum_buf_len = 0;
                    input_buf_len = sizeof(fwupdate.accum_buf);
                }
                // otherwise use a block directly from original buffer if available
                else if (len >= sizeof(fwupdate.accum_buf)) {
                    // No waiting bytes and we have enough to process another block(s)
                    input_buf = (const uint8_t*)buf + offset;
                    printf("@   use buf at %d\n", offset);

                    /* We will try to consume all bytes that are a multiple of the accumulation buffer. 
                    The rest will get consumed into the accumulation buffer and held for the next packet received. 
                    */
                    input_buf_len = (len / sizeof(fwupdate.accum_buf)) * sizeof(fwupdate.accum_buf);
                    len -= input_buf_len;
                    offset += input_buf_len;
                }
                /* ----------------------------------------------------------------- */

                /* Only if there is at least one accum_buf number of bytes available */
                if (input_buf) {
                   
                    //print_hex_buf((const uint8_t*)input_buf, input_buf_len);

                    SE_PATCH_InitStatus(&se_patch_status);
                    SE_ErrorStatus se_status = SE_PATCH_Data(&se_patch_status, input_buf, input_buf_len);
                    printf("@ fwupdate DATA len=%d status=%d\n", input_buf_len, se_status);
                    fwupdate_PrintStatus(&se_patch_status);
                    if (se_status == SE_ERROR) {
                        fwupdate_send_err(conn, fwupdate_GetStatusCodeString(se_patch_status.code));
                        ret = FWUPDATE_STATUS_ERROR;
                        fwupdate.state = FWUPDATE_STATE_HEADER;
                    }
                    else {
                        fwupdate.accum_length += len;
                    }
                }
            }

            /* In any case we have consumed all bytes remaining in this buffer */
            buf = 0;

            if (ret == FWUPDATE_STATUS_INPROGRESS) {
                if (fwupdate.accum_length >= fwupdate.file_length
                    || se_patch_status.stage == SE_PATCH_Stage_VERIFIED)
                {
                    /* now the thing is, if rebootdelay_IMMEDIATE was selected, the device will have rebooted
                    before we get here. 
                    */
                    /* A better flow would be to have a response sent that said "firmware update success!" 
                    with a countdown timer "rebooting in 5,4,3,2,1" then when device comes back up, the client browser
                    should be polling the firmware update page to show that updated firmware is present by way of the
                    updated version string.
                    */
                    /* if we have all file bytes, we are done whether it worked or not */
                    ret = FWUPDATE_STATUS_DONE;
                    fwupdate.state = FWUPDATE_STATE_HEADER;
                }
            }

            break;
        }
        }
    } /* while (buf) */

    return ret;
}


/**
  * @brief serve tcp connection  
  * @param conn: pointer on connection structure 
  * @retval None
  */
static void http_server_serve(struct netconn *conn) 
{
  struct netbuf *inbuf;
  err_t recv_err;
  char* buf;
  u16_t buflen;
  struct fs_file file;
  /* Normal GET requests are expected to be closed by us after sending the response. */
  bool close = true;
  
  printf("===== http_server_serve recv\n");

  /* Read the data from the port, blocking if nothing yet there. 
   We assume the request (the part we care about) is in one netbuf */
  while ((recv_err = netconn_recv(conn, &inbuf)) == ERR_OK) 
  {
    if (netconn_err(conn) == ERR_OK) 
    {
        printf("# netconn_recv inbuf\n");
        do {
            netbuf_data(inbuf, (void**)&buf, &buflen);
            printf("# Process buffer: %p %d bytes\n", buf, buflen);

            /* Is this an HTTP GET command? (only check the first 5 chars, since
            there are other formats for GET, and we're keeping it very simple )*/
            if ((buflen >= 5) && (strncmp(buf, "GET /", 5) == 0))
            {
                printf("# GET\n");
                /* Check if request to get ST.gif */
                if (strncmp((char const*)buf, "GET /STM32F4xx_files/ST.gif", 27) == 0)
                {
                    fs_open(&file, "/STM32F4xx_files/ST.gif");
                    netconn_write(conn, (const unsigned char*)(file.data), (size_t)file.len, NETCONN_NOCOPY);
                    fs_close(&file);
                }
                /* Check if request to get stm32.jpeg */
                else if (strncmp((char const*)buf, "GET /STM32F4xx_files/stm32.jpg", 30) == 0)
                {
                    fs_open(&file, "/STM32F4xx_files/stm32.jpg");
                    netconn_write(conn, (const unsigned char*)(file.data), (size_t)file.len, NETCONN_NOCOPY);
                    fs_close(&file);
                }
                else if (strncmp((char const*)buf, "GET /STM32F4xx_files/logo.jpg", 29) == 0)
                {
                    /* Check if request to get ST logo.jpg */
                    fs_open(&file, "/STM32F4xx_files/logo.jpg");
                    netconn_write(conn, (const unsigned char*)(file.data), (size_t)file.len, NETCONN_NOCOPY);
                    fs_close(&file);
                }
                else if (strncmp(buf, "GET /STM32F4xxTASKS.html", 24) == 0)
                {
                    /* Load dynamic page */
                    DynWebPage(conn);
                }
                else if (strncmp(buf, "GET /firmwareupdate.html", 24) == 0)
                {
                    /* Load firmware update page */
                    FwUpdWebPage(conn);
                }
                else if ((strncmp(buf, "GET /STM32F4xx.html", 19) == 0) || (strncmp(buf, "GET / ", 6) == 0))
                {
                    /* Load STM32F4xx page */
                    fs_open(&file, "/STM32F4xx.html");
                    netconn_write(conn, (const unsigned char*)(file.data), (size_t)file.len, NETCONN_NOCOPY);
                    fs_close(&file);
                }
                else
                {
                    /* Load Error page */
                    fs_open(&file, "/404.html");
                    netconn_write(conn, (const unsigned char*)(file.data), (size_t)file.len, NETCONN_NOCOPY);
                    fs_close(&file);
                }
            }
            else {
                /* Not a handled GET request - process this as a potential multipart form POST */
                int ret = fwupdate_multipart_state_machine(conn, buf, buflen);
                if (ret == FWUPDATE_STATUS_NONE) {
                    /* ignore */
                }
                else if (ret == FWUPDATE_STATUS_INPROGRESS) {
                    /* Don't close the connection! */
                    close = false;
                }
                else {
                    /* Some result, we should close the connection now. */
                    close = true;
                }            
            }
            /* Process all data that may be present in the netbuf */
            printf("# netbuf_next = %d\n", netbuf_next(inbuf));
        } while (netbuf_next(inbuf) >= 0);

        /* Delete the buffer (netconn_recv gives us ownership,
         so we have to make sure to deallocate the buffer) */
        netbuf_delete(inbuf);
    }
    else {
        printf("# netconn_recv error: %d %d\n", recv_err, netconn_err(conn));
    }
    if (close) {
        /* Action requires us to close the connection now instead of
        blocking on the next netconn_recv. */
        break;
    }
  } /* while netconn_recv */

  printf("===== http_server_serve close\n");
  /* Close the connection (server closes in HTTP) */
  netconn_close(conn);

}


/**
  * @brief  http server thread 
  * @param arg: pointer on argument(not used here) 
  * @retval None
  */
static void http_server_netconn_thread(void *arg)
{ 
  struct netconn *conn, *newconn;
  err_t err, accept_err;
  
  /* Create a new TCP connection handle */
  conn = netconn_new(NETCONN_TCP);
  
  if (conn!= NULL)
  {
    /* Bind to port 80 (HTTP) with default IP address */
    err = netconn_bind(conn, NULL, 80);
    
    if (err == ERR_OK)
    {
      /* Put the connection into LISTEN state */
      netconn_listen(conn);
  
      while(1) 
      {
        /* accept any icoming connection */
        accept_err = netconn_accept(conn, &newconn);
        if(accept_err == ERR_OK)
        {
          /* serve connection */
          http_server_serve(newconn);

          /* delete connection */
          netconn_delete(newconn);
        }
      }
    }
  }
}

/**
  * @brief  Initialize the HTTP server (start its thread) 
  * @param  none
  * @retval None
  */
void http_server_netconn_init()
{
  sys_thread_new("HTTP", http_server_netconn_thread, NULL, DEFAULT_THREAD_STACKSIZE, WEBSERVER_THREAD_PRIO);
}

/**
  * @brief  Create and send a dynamic Web Page. This page contains the list of 
  *         running tasks and the number of page hits. 
  * @param  conn pointer on connection structure 
  * @retval None
  */
void DynWebPage(struct netconn *conn)
{
  portCHAR PAGE_BODY[512];
  portCHAR pagehits[10] = {0};

  memset(PAGE_BODY, 0,512);

  /* Update the hit count */
  nPageHits++;
  sprintf(pagehits, "%d", (int)nPageHits);
  strcat(PAGE_BODY, pagehits);
  strcat((char *)PAGE_BODY, "<pre><br>Name          State  Priority  Stack   Num" );
  strcat((char *)PAGE_BODY, "<br>---------------------------------------------<br>");
    
  /* The list of tasks and their status */
  osThreadList((unsigned char *)(PAGE_BODY + strlen(PAGE_BODY)));
  strcat((char *)PAGE_BODY, "<br><br>---------------------------------------------");
  strcat((char *)PAGE_BODY, "<br>B : Blocked, R : Ready, D : Deleted, S : Suspended<br>");

  /* Send the dynamically generated page */
  netconn_write(conn, PAGE_START, strlen((char*)PAGE_START), NETCONN_COPY);
  netconn_write(conn, PAGE_BODY, strlen(PAGE_BODY), NETCONN_COPY);
}

void FwUpdWebPage(struct netconn *conn)
{
  portCHAR PAGE_BODY[512];

  memset(PAGE_BODY, 0,512);

  /* Update the bootloader version */
  int n = 0;
  SE_StatusTypeDef se_Status = SE_KO;
  char buf[32];
  int ret = SE_APP_GetBootVer(&se_Status, buf, sizeof(buf));
  if (ret == SE_SUCCESS) {
      n += snprintf(PAGE_BODY, sizeof(PAGE_BODY) - n, "%s", buf);
  } else {
      n += snprintf(PAGE_BODY, sizeof(PAGE_BODY) - n, "Error: %d", se_Status);
  }

  n += snprintf((char*)PAGE_BODY + n, sizeof(PAGE_BODY) - n, "<br>Firmware version:");
  SE_APP_ActiveFwInfo sl_FwInfo;
  memset(&sl_FwInfo, 0x0, sizeof(SE_APP_ActiveFwInfo));
  ret = SE_APP_GetActiveFwInfo(&se_Status, &sl_FwInfo);
  if (ret == SE_SUCCESS) {
      n += snprintf((char*)PAGE_BODY + n, sizeof(PAGE_BODY) - n, " %ld.%ld.%ld",
          FW_VERSION_MAJOR(sl_FwInfo.ActiveFwVersion),
          FW_VERSION_MINOR(sl_FwInfo.ActiveFwVersion),
          FW_VERSION_PATCH(sl_FwInfo.ActiveFwVersion));
      n += snprintf((char*)PAGE_BODY + n, sizeof(PAGE_BODY) - n, "<br>Firmware size: %ld",
          sl_FwInfo.ActiveFwSize);
  }
  else {
      n += snprintf((char*)PAGE_BODY + n, sizeof(PAGE_BODY) - n, "Error: %d",
          se_Status);
  }

  n += snprintf((char*)PAGE_BODY + n, sizeof(PAGE_BODY) - n,
      "</span><br><br>"
#if 1
      "<form id=\"form\" action=\"upload\" method=\"post\" enctype=\"multipart/form-data\">"
      "<input id=\"file\" type=\"file\" name=\"binary\" accept=\".sfb,.sfbp\">"
      "<button type=\"submit\">upload</button>"
#endif
#if 0
      "<form id=\"form\" action=\"upload\" method=\"post\" enctype=\"multipart/form-data\">"
      "<input id=\"file\" type=\"file\" name=\"filename\" accept=\".sfb,.sfbp\"/>"
      "<input type=\"submit\" value=\"upload\"/>"
#endif
#if 0
      "<form id=\"form\" enctype=\"multipart/form-data\">"
      "<label for=\"file\">Select file</label>"
      "<input id=\"file\" type=\"file\" accept=\".sfb,.sfbp\"/>"
      "<button type=\"submit\">Upload</button>"
      "<script>uploadFile()</script>"
#endif
      "</form></body></html>");

  /* Send the dynamically generated page */
  netconn_write(conn, PAGE_START_FWUPD, strlen((char*)PAGE_START_FWUPD), NETCONN_COPY);
  netconn_write(conn, PAGE_BODY, strlen(PAGE_BODY), NETCONN_COPY);
}
